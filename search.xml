<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java泛型总结</title>
    <url>/java/01_%E8%AF%B4%E8%AF%B4Java%E6%B3%9B%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="什么是Java泛型"><a href="#什么是Java泛型" class="headerlink" title="什么是Java泛型"></a>什么是Java泛型</h2><p>&emsp;&emsp;Java泛型(Java generic)是JDK 5引入的一个新特性.其本质就是参数化类型,也就是把数据类型视作为一个参数,在使用的时候再指定具体类型,这种参数化类型就是泛型.泛型可以用在类,接口,方法上,分别称之为泛型类,泛型接口,泛型方法.<br>&emsp;&emsp;泛型的出现为程序员提供了一种编译时类型安全的监测机制,使程序员能够在编译期间找出非法类型的存在,提高开发的安全性和效率.<br>&emsp;&emsp;Java中的泛型一种伪泛型,使用了类型擦除实现的,本质上是Java语言的语法糖.</p>
<hr>
<h2 id="为什么出现Java泛型"><a href="#为什么出现Java泛型" class="headerlink" title="为什么出现Java泛型"></a>为什么出现Java泛型</h2><p>看下面的情形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们为了实现不同数据类型的add方法,就需要给每种类型都写一个重载方法,这显然不符合我们开发的需求.</p>
<p>&emsp;&emsp;如果我们在这里使用泛型的话,就不需要给每种数据类型都增加一个重载方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.doubleValue() + b.doubleValue() ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我们在这里使用泛型的话,就不需要给每种数据类型都增加一个重载方法.</p>
<p>再看下面的情形</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/01.png" alt="step1"></p>
<p>&emsp;&emsp;在上面代码我们定义了一个List类型的集合,先向里面加入了两个String类型的值,然后又加入了一个Integer类型的值,这在Java编译期间是允许的,因为List默认的类型是Object.在后面的循环中,因为之前加入的数据类型不一样,很可能出现ClassCastException异常.</p>
<p> 从上我们可以大概总结到泛型有以下好处<br><font color=#ff0000>1,代码复用,增加代码拓展性</font><br><font color=#ff0000>2,消除强制类型转换,类型安全</font></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>&emsp;&emsp;泛型可以用在类,接口,方法上,分别可以称为泛型类,泛型接口,泛型方法.</p>
<h4 id="泛型类-泛型接口"><a href="#泛型类-泛型接口" class="headerlink" title="泛型类/泛型接口"></a>泛型类/泛型接口</h4><p>&emsp;&emsp;泛型类和泛型接口的定义基本相同,就是引入一个类型变量T(其他大写字母也OK,一般约定俗成的有T,E,V,K,N等),并用&lt;&gt;括起来,放在类名/接口名的后面,泛型类和接口允许有多个类型变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> K result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>&emsp;&emsp;泛型方法,是在调用方法的时候指明泛型的具体类型,泛型方法可以在任意地方任意场景中使用,包括普通类和泛型类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">handleData</span><span class="params">(V data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<font color=#ff0000>一定要注意的是,并不是方法中参数或者返回值包含了泛型的就是泛型方法,只有在调用的时候需要指明泛型的才是泛型方法.</font></p>
<h2 id="限定类型变量"><a href="#限定类型变量" class="headerlink" title="限定类型变量"></a>限定类型变量</h2><p>&emsp;&emsp;有时候,我们需要对泛型的类型进行限定,比如说我们写一个泛型方法比较两个变量的大小,我们怎么确保传入的两个变量都一定有compareTo方法呢?这个时候我们就可以使用T extends Comparable对泛型的类型变量进行限制,<br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/02.png" alt="step2"></p>
<p>&emsp;&emsp;T表示应该绑定类型的子类型,Comparable表示绑定的类型,子类型和绑定类型可以试类,也可以是接口<br>&emsp;&emsp;这个时候如果我们试图传入一个没有实现接口Comparable的实例变量,将会发生变异错误<br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/3.png" alt="step3"></p>
<h2 id="泛型类的继承规则"><a href="#泛型类的继承规则" class="headerlink" title="泛型类的继承规则"></a>泛型类的继承规则</h2><p><font color=#0099FF>1,泛型参数是继承关系的,泛型类之间没有继承关系</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendPet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Pet&lt;Animal&gt; genericClass =<span class="keyword">new</span> Pet&lt;Cat&gt;(); <span class="comment">//错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=#0099FF>2,泛型类是可以继承其他泛型类的,比如List和ArrayList</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendPet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Pet&lt;Animal&gt; genericClass =<span class="keyword">new</span> ExtendPet&lt;&gt;(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h2><h3 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h3><p>&emsp;&emsp;在讲泛型通配符之前,我们先了解下数组,在Java中,数组是可以<font color=#0099FF>协变</font>的,什么是<font color=#0099FF>协变</font>,我们以下面的例子讲解下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingBa</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Animal[] animals = <span class="keyword">new</span> Dog[<span class="number">5</span>];</span><br><span class="line">       animals[<span class="number">0</span>] = <span class="keyword">new</span> Dog();<span class="comment">//可以</span></span><br><span class="line">       animals[<span class="number">1</span>] = <span class="keyword">new</span> JingBa();<span class="comment">//可以</span></span><br><span class="line">       System.out.println(animals.getClass());</span><br><span class="line">       System.out.println(animals[<span class="number">0</span>].getClass());</span><br><span class="line">       System.out.println(animals[<span class="number">1</span>].getClass());</span><br><span class="line">       <span class="comment">//animals[2] = new Animal();//ArrayStoreException</span></span><br><span class="line">       <span class="comment">// animals[3] = new Cat();//ArrayStoreException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">class [Lcom.company.genneric.Dog;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">company</span>.<span class="title">genneric</span>.<span class="title">Dog</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">company</span>.<span class="title">genneric</span>.<span class="title">JingBa</span></span></span><br><span class="line"><span class="class">----------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,创建一个Dog数组并将他赋值给Animal数组的引用.像这种具有子父类关系的类,子类数组也是父类数组的情况就是<font color=#0099FF>数组协变</font><br>&emsp;&emsp;不过在使用<font color=#0099FF>数组协变</font>,也有些事情要注意,就是有些问题在运行的时候才能发现.还是看上面的代码.尽管Dog[]可以”向上转型”为Animal[],但是数组中实际的类型还是Dog对象,我们在上面放入Dog或者Dog的子类JingBa的对象时都是可以的,但是在放入Animal或者Cat对象的时候会在运行的时候报ArrayStoreException异常.<br>&emsp;&emsp;泛型设计的目的之一就是将一些运行时候的错误暴露在编译期间,我们下面使用Java提供的泛型容器List,看下会发生什么.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/07.png" alt="step7"><br>&emsp;&emsp;看到了,上面的代码根本无法编译,直接报错,当涉及到泛型的时候,尽管Dog是Animal的子类,ArrayList<Dog>却不是ArrayList<Animal>的子类,也就是说泛型不支持<font color=#0099FF>协变</font></p>
<h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>&emsp;&emsp;如果我们要实现类似上面数组的<font color=#0099FF>协变</font>怎么办呢,这时候我们就用到了通配符.Java中泛型通配符分为3种,我们依次来讲.</p>
<h4 id="上边界通配符"><a href="#上边界通配符" class="headerlink" title="上边界通配符"></a>上边界通配符</h4><p>&emsp;&emsp;使用<code>&lt;? extends Parent&gt;</code>的就是上边界通配符,他指定了泛型类型的上边界,类型参数都是Parent的子类,通过这种通配符可以实现泛型的”向上转型”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(new Dog());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new JingBa());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Cat()));//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object()));//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        Animal a = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,list的类型是List&lt;? extends Animal&gt;,可以把list看成是一个类型的List,这个类型是可以继承Animal的,但是需要注意的是,这并不是说这个List就可以持有Animal的任意类型.通配符代表的是某种特定的类型,但是上面的list没有指定实际的类型,它可以是Animal的任何子类型,Animal是它的上边界.</p>
<p>&emsp;&emsp;既然我们不知道这个list是什么类型,那我们如果安全的添加一个对象呢?在上面的例子中我们也看到了,无论是添加Dog,JingBa,Cat还是Object对象,编译器都会报错,唯一能通过编译的就是null.所以如果我们写了向上转型<code>&lt;? extends Parent&gt;</code>的泛型那么我们的List将失去添加任务对象的能力,及时Object对象也不行.</p>
<p>&emsp;&emsp;另外如果我们获取返回Animal的方法,这是可以的,因为在这个list中,不管它实际的类型到底是什么,肯定可以转型成Animal的,所有向上转型返回数据是允许的.</p>
<p><font color=#0099FF>总结:主要用于安全地访问数据，可以访问Parent及其子类型，并且不能写入非null的数据</font></p>
<h4 id="下边界通配符"><a href="#下边界通配符" class="headerlink" title="下边界通配符"></a>下边界通配符</h4><p>&emsp;&emsp;使用<code>&lt;? super Child&gt;</code>的就是下边界通配符,他指定了泛型类型的下边界,类型参数都是Child的基类,通过这种通配符可以实现泛型的”向下转型”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;? <span class="keyword">super</span> Dog&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        list.add(<span class="keyword">new</span> JingBa());</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//        list.add(new Cat());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        Object object = list.get(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,我们也不能确定list里的是什么类型,但是我们知道这个类型一定是Dog的基类(父类),因此我们向里面添加一个Dog对象或者Dog子类型的对象是安全的,这些对象都可以向上转型为Dog.我们在取出list里面的数据的时候,返回的一定是Dog的基类(父类),但到底是哪一个基类(父类)我们是不知道的,但在java中所有的类型都继承自Object,所有在list取出的数据,返回的一定是Object.</p>
<p><font color=#0099FF>总结:主要用于安全地写入数据，可以写入Child及其子类型</font></p>
<h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h4><p><code>&lt;?&gt;</code>无边界通配符,没有任何限定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        list.add(new Animal());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Dog());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Cat());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        Object object = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>List&lt;?&gt;</code>表示持有某种特定类型的List,但是这种List并没有指定具体类型,这是不安全的,所以我们不能向里面添加除null以外的对象</p>
<h5 id="List-lt-gt-与List的区别"><a href="#List-lt-gt-与List的区别" class="headerlink" title="List&lt;?&gt;与List的区别?"></a><code>List&lt;?&gt;</code>与List的区别?</h5><p>&emsp;&emsp;List没有泛型参数,表明这个List持有元素的类型是Object,因此可以添加任何类型的对象,不过编译器会有警告信息.</p>
<h2 id="泛型中的约束和局限性"><a href="#泛型中的约束和局限性" class="headerlink" title="泛型中的约束和局限性"></a>泛型中的约束和局限性</h2><p> <font color=#ff0000>1,不能用基本数据类型实例化类型参数</font><br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/4.png" alt="step4"></p>
<p>  <font color=#ff0000>2,运行时类型查询只适用于原始类型</font><br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/5.png" alt="step5"></p>
<p>  <font color=#ff0000>3,泛型类的静态变量或者方法不能使用泛型类型</font><br>  注:静态方法本身就是泛型方法除外<br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/6.png" alt="step6"><br>   &emsp;&emsp;不能在静态方法和变量中引用泛型类型变量,因为泛型是在对象创建的时候才知道是什么类型,而对象创建代码的执行顺序是static,构造方法,所以在对象初始化之前static的部分已经执行了.</p>
<p>  <font color=#ff0000>4,不能创建泛型数组</font><br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/08.png" alt="step8"></p>
<h2 id="虚拟机中泛型的实现-类型擦除"><a href="#虚拟机中泛型的实现-类型擦除" class="headerlink" title="虚拟机中泛型的实现-类型擦除"></a>虚拟机中泛型的实现-类型擦除</h2><p>&emsp;&emsp;Java泛型是在Java1.5以后才出现的,在Java早期版本中并没有泛型概念,为了向下兼容,Java泛型只存在在编译期,在编译后,就会替换成原生类型,并在相应的地方插入强制转换类型的代码,因此对于运行期的Java语言来说,ArrayList<Int>和ArrayList<String>就是一个类,这种编译后去除类型信息的方式就叫做类型擦除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;泛型参数会擦除到他的第一个边界,如果参数类型是单独的一个T,那么最终会擦除到Object,相当于所有使用T的地方都会被Object替换,对于虚拟机来说,最终保存的参数类型还是Object.之所以还可以取出来我们传入的参数类型,是因为编译器在编译生成字节码的过程中,插入了类型转换的代码.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm报错 Environment location directory is not empty解决</title>
    <url>/idea/error/pycharm/01_Environment-location-directory-is-not-empty%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<h1 id="出现情景"><a href="#出现情景" class="headerlink" title="出现情景"></a>出现情景</h1><p>&emsp;&emsp;重新安装PyCharm导入之前的项目,或者使用Pycharm创建新项目的时候可能会出现<br><font color=#0099FF>Environment location directory is not empty</font>提示.</p>
<h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>&emsp;&emsp;配置环境的目录不是空的</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>&emsp;&emsp;将Project interpreter 的Location修改为空文件夹,建议放入一个统一的目录下,方便管理.<br><img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/idea/pycharm/error/01/02.png" alt="修改Location"></p>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
      <tags>
        <tag>Pycharm</tag>
        <tag>Idea使用问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Intellij idea 2019.3激活教程</title>
    <url>/skill/01_Intellij%20idea2019.3%E7%A0%B4%E8%A7%A3.html</url>
    <content><![CDATA[<p>&emsp;&emsp;2019年开始Jetbrains对旗下产品进行了一次升级,之前激活码激活Intellij idea的方式都不能使用了.本文以 <a href="https://download.jetbrains.com/idea/ideaIU-2019.3.5.exe?_ga=2.209285586.1795243078.1605170605-1922567665.1600847694">Intellij idea 2019.3</a>为例,讲解一下Intellij idea的激活.以下方法对Jetbrains旗下其他产品,如Webstorm,PyCharm等同样适用.</p>
<h2 id="下载破解插件"><a href="#下载破解插件" class="headerlink" title="下载破解插件"></a>下载破解插件</h2><p>&emsp;&emsp;下载jetbrains-agent.jar破解插件,<a href="https://pan.baidu.com/s/1XMw2cUR5dMHscCqL42hexQ">百度云盘</a>提取码：syfq.下载完成后,将插件放入自己容易找到没有中文字符的文件夹下面(建议放入idea的bin目录下),复制路径.</p>
<h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><h3 id="在Idea右上角点击-Help-gt-Edit-Custom-VM-Options"><a href="#在Idea右上角点击-Help-gt-Edit-Custom-VM-Options" class="headerlink" title="在Idea右上角点击 Help-&gt;Edit Custom VM Options."></a>在Idea右上角点击 Help-&gt;Edit Custom VM Options.</h3><p> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/01.png" alt="选择Edit Custom VM Options"></p>
<h3 id="打开idea64-exe-vmoptions文件-最后一行增加-javaagent"><a href="#打开idea64-exe-vmoptions文件-最后一行增加-javaagent" class="headerlink" title="打开idea64.exe.vmoptions文件,最后一行增加-javaagent:"></a>打开idea64.exe.vmoptions文件,最后一行增加-javaagent:</h3><p> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/02.png" alt="idea64.exe.vmoptions文件"><br>&emsp;&emsp;填写-javaagent:式例<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-javaagent:C:\********************\jetbrains-agent.jar </span><br></pre></td></tr></table></figure></p>
<h2 id="填写激活码"><a href="#填写激活码" class="headerlink" title="填写激活码"></a>填写激活码</h2><h3 id="在Idea右上角点击-Help-gt-Register-选择Activation-Code"><a href="#在Idea右上角点击-Help-gt-Register-选择Activation-Code" class="headerlink" title="在Idea右上角点击 Help-&gt;Register,选择Activation Code"></a>在Idea右上角点击 Help-&gt;Register,选择Activation Code</h3><p> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/03.png" alt="打开Register框"><br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/04.png" alt="填写Activation Code"></p>
<h3 id="填写激活码-1"><a href="#填写激活码-1" class="headerlink" title="填写激活码"></a>填写激活码</h3><p>有限期:2089年<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">520E5894E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ&#x2F;oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba&#x2F;uTcCh&#x2F;L37meyD0FJdJIprv59y4+n+k2kIeF&#x2F;XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx&#x2F;F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH&#x2F;a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG&#x2F;PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg&#x2F;nYV31HLF7fJUAplI&#x2F;1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4&#x2F;G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd&#x2F;GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt&#x2F;wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59&#x2F;THOT7NJQhr6AyLkhhJCdkzE2cob&#x2F;KouVp4ivV7Q3Fc6HX7eepHAAF&#x2F;DpxwgOrg9smX6coXLgfp0b1RU2u&#x2F;tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB&#x2F;40BjpMUrDRCeKuiBahC0DCoU&#x2F;4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV&#x2F;g&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><br>有限期:2089年</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N757JE0KCT-eyJsaWNlbnNlSWQiOiJONzU3SkUwS0NUIiwibGljZW5zZWVOYW1lIjoid3UgYW5qdW4iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIwLTAxLTA3In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDIwLTAxLTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMjAtMDEtMDcifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIwLTAxLTA3In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjAtMDEtMDcifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjAtMDEtMDcifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIwLTAxLTA3In0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjAtMDEtMDcifSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIwLTAxLTA3In0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjAtMDEtMDcifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMC0wMS0wNyJ9XSwiaGFzaCI6IjExNTE5OTc4LzAiLCJncmFjZVBlcmlvZERheXMiOjAsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0&#x3D;-AE3x5sRpDellY4SmQVy2Pfc2IT7y1JjZFmDA5JtOv4K5gwVdJOLw5YGiOskZTuGu6JhOi50nnd0WaaNZIuVVVx3T5MlXrAuO3kb2qPtLtQ6&#x2F;n3lp4fIv+6384D4ciEyRWijG7NA9exQx39Tjk7&#x2F;xqaGk7ooKgq5yquIfIA+r4jlbW8j9gas1qy3uTGUuZQiPB4lv3P5OIpZzIoWXnFwWhy7s&#x2F;&#x2F;mjOWRZdf&#x2F;Du3RP518tMk74wizbTeDn84qxbM+giNAn+ovKQRMYHtLyxntBiP5ByzfAA9Baa5TUGW5wDiZrxFuvBAWTbLrRI0Kd7Nb&#x2F;tB9n1V9uluB2WWIm7iMxDg&#x3D;&#x3D;-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO&#x2F;5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij&#x2F;78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB&#x2F;xVy&#x2F;VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE&#x2F;EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl&#x2F;GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn&#x2F;72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN&#x2F;lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D&#x2F;cXmgpOyW&#x2F;1SmBz3XjVIi&#x2F;zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV&#x2F;bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit&#x2F;pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="重启Idea"><a href="#重启Idea" class="headerlink" title="重启Idea"></a>重启Idea</h3>]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
        <tag>Intellij idea</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
</search>
