<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flutter的八种状态管理</title>
    <url>/flutter/01_flutter%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<p>&emsp;&emsp;所有程序里界面和数据的交互都至关重要，直接决定了整个程序的结构，选好状态管理方案的重要性就不言而喻了。我以为状态管理分为两类.</p>
<hr>
<h2 id="一-Dart-和-Flutter-内置支持"><a href="#一-Dart-和-Flutter-内置支持" class="headerlink" title="一,Dart 和 Flutter 内置支持"></a>一,Dart 和 Flutter 内置支持</h2><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a><font color=#ff6633>setState</font></h3><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">setState(()&#123; </span><br><span class="line">  _model = model; </span><br><span class="line">&#125;); <span class="comment">// mounted</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;最重要的方式 setState，支持规模较小的程序足够了，所有其它方式最终都需要调用 setState。</p>
<h3 id="方法回调-Function-callback"><a href="#方法回调-Function-callback" class="headerlink" title="(方法回调)Function callback"></a><font color=#ff6633>(方法回调)Function callback</font></h3><p>&emsp;&emsp;Dart Function 足够灵活，还支持模版参数。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> FooChanged = <span class="keyword">void</span> <span class="built_in">Function</span>(<span class="built_in">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ValueChanged&lt;T&gt; = <span class="keyword">void</span> <span class="built_in">Function</span>(T value);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;单向变更通知，可以和ObserverList结合支持多个订阅者。<br>Flutter 内置 ChangeNotifier, ValueNotifier 都可以认为是类似方案。</p>
<h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a><font color=#ff6633>Delegate</font></h3><p>&emsp;&emsp;可以认为是多个回调函数，其他语言里都有类似模式，名称似乎来源于 Objective-C。实际例子.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiderDelegate</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="markdown">category is null, crawl book whole site</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">category not null, crawl book under the category</span></span></span><br><span class="line">  <span class="keyword">void</span> onBook(Book book, &#123;Site site, Category category&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> onChapter(Book book, Chapter chapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Sigslot"><a href="#Sigslot" class="headerlink" title="Sigslot"></a><font color=#ff6633>Sigslot</font></h3><p>&emsp;&emsp;源自 Qt 里的经典编程模式，Dart 可以轻易实现。这种方式在 Flutter 里可能根本不会有太多应用，但是由于 Sigslot 在 C++ 领域具有举足轻重的地位，属于界面数据和逻辑解耦合的王者，boost::signal(2)就是明证，在这里列出纯属凑数(本人也实现了一个).</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> ValueCallback&lt;E&gt; = <span class="keyword">void</span> <span class="built_in">Function</span>(E value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Signable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// Signable&lt;bool&gt; someValue;</span></span><br><span class="line">  <span class="comment">/// <span class="markdown">Register a closure to be called when the object notifies its listeners.</span></span></span><br><span class="line">  <span class="keyword">void</span> connect(ValueCallback&lt;E&gt; listener);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">Remove a previously registered closure from the list of closures that the</span></span></span><br><span class="line">  <span class="comment">/// <span class="markdown">object notifies.</span></span></span><br><span class="line">  <span class="keyword">void</span> disconnect(ValueCallback&lt;E&gt; listener);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="markdown">sink value changed</span></span></span><br><span class="line">  <span class="keyword">void</span> emit(E value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法类似</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Signal&lt;<span class="built_in">String</span>&gt; signalString;</span><br><span class="line"></span><br><span class="line">signalString.connect((<span class="built_in">String</span> str) &#123;</span><br><span class="line">  <span class="comment">// got the `str` changed here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="二-包-外部实现"><a href="#二-包-外部实现" class="headerlink" title="二 ,包-外部实现"></a>二 ,包-外部实现</h2><h3 id="pkg-scoped-model"><a href="#pkg-scoped-model" class="headerlink" title="pkg:scoped_model"></a><font color=#ff6633>pkg:scoped_model</font></h3><p>&emsp;&emsp;个人以为是最佳方案，源自 Fuchsia 代码，在其中广泛使用，设置程序几乎都是这个模式，后来独立为 package，包括注释也只有 287 行代码。由于 Fuchsia App 结构都是后台Service+前台UI，这个方案绝对是最合适的方案。使用 InheritedWidget 实现，性能不可能更好.<br>&emsp;&emsp;例子太多，Flutter 官方 samples 里也有链接.</p>
<h3 id="pkg-provide"><a href="#pkg-provide" class="headerlink" title="pkg:provide"></a><font color=#ff6633>pkg:provide</font></h3><p>&emsp;&emsp;出自 Flutter dev team，绝对的官方了，总共代码 675行。实现方式和 scoped_model 类似，增加 Providers，Provider 支持 Stream.</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Column(children: [</span><br><span class="line">      <span class="comment">// Simplest way to retrieve the provided value.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Each time the counter changes, this will get rebuilt. This widget</span></span><br><span class="line">      <span class="comment">// requires the value to be a Listenable or a Stream. Otherwise</span></span><br><span class="line">      Provide&lt;Counter&gt;(</span><br><span class="line">        builder: (context, child, counter) =&gt; Text(<span class="string">&#x27;<span class="subst">$&#123;counter.value&#125;</span>&#x27;</span>),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This widget gets the counter as a stream of changes.</span></span><br><span class="line">      <span class="comment">// The stream is filtered so that this only rebuilds on even numbers.</span></span><br><span class="line">      StreamBuilder&lt;Counter&gt;(</span><br><span class="line">          initialData: currentCounter,</span><br><span class="line">          stream: Provide.stream&lt;Counter&gt;(context)</span><br><span class="line">              .where((counter) =&gt; counter.value % <span class="number">2</span> == <span class="number">0</span>),</span><br><span class="line">          builder: (context, snapshot) =&gt;</span><br><span class="line">              Text(<span class="string">&#x27;Last even value: <span class="subst">$&#123;snapshot.data.value&#125;</span>&#x27;</span>)),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// This button just needs to call a method on Counter. No need to rebuild</span></span><br><span class="line">      <span class="comment">// it as the value of Counter changes. Therefore, we can use the value of</span></span><br><span class="line">      <span class="comment">// `Provide.value&lt;Counter&gt;` from above.</span></span><br><span class="line">      FlatButton(child: Text(<span class="string">&#x27;increment&#x27;</span>), onPressed: currentCounter.increment),</span><br><span class="line"></span><br><span class="line">      Text(<span class="string">&#x27;Another widget that does not depend on the Counter&#x27;</span>),</span><br><span class="line">    ]);</span><br></pre></td></tr></table></figure>
<h3 id="flutter-provide"><a href="#flutter-provide" class="headerlink" title="flutter-provide"></a><font color=#ff6633>flutter-provide</font></h3><p>&emsp;&emsp;可以认为这个比 provide 更早，功能更丰富，实现依然是 InheritedWidget。可能不会有太广泛使用，但是在时间上有历史意义，故列出.</p>
<h3 id="RxDart-Fish-Redux"><a href="#RxDart-Fish-Redux" class="headerlink" title="RxDart, Fish-Redux"></a><font color=#ff6633>RxDart, Fish-Redux</font></h3><p>&emsp;&emsp;看过以上各种实现后，我不知道还有什么理由一定要用 RxDart 之类重量级的实现。程序结构会被绑架，学习曲线也更高。不得不提 Bloc 是个另类，使用 RxDart 了，但是做到更简洁，对 Infinite List 等也有较好实现.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;就好像组合是使用最多的设计模式，函数回调、类回调可能就是小规模的App最佳状态管理。稍微规模程序，数据和界面都应该分层(类似 Fuchsia App)，最佳方案可能就是 scoped_model.</p>
]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型总结</title>
    <url>/java/01_%E8%AF%B4%E8%AF%B4Java%E6%B3%9B%E5%9E%8B.html</url>
    <content><![CDATA[<h2 id="什么是Java泛型"><a href="#什么是Java泛型" class="headerlink" title="什么是Java泛型"></a>什么是Java泛型</h2><p>&emsp;&emsp;Java泛型(Java generic)是JDK 5引入的一个新特性.其本质就是参数化类型,也就是把数据类型视作为一个参数,在使用的时候再指定具体类型,这种参数化类型就是泛型.泛型可以用在类,接口,方法上,分别称之为泛型类,泛型接口,泛型方法.<br>&emsp;&emsp;泛型的出现为程序员提供了一种编译时类型安全的监测机制,使程序员能够在编译期间找出非法类型的存在,提高开发的安全性和效率.<br>&emsp;&emsp;Java中的泛型一种伪泛型,使用了类型擦除实现的,本质上是Java语言的语法糖.</p>
<hr>
<h2 id="为什么出现Java泛型"><a href="#为什么出现Java泛型" class="headerlink" title="为什么出现Java泛型"></a>为什么出现Java泛型</h2><p>看下面的情形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">add</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们为了实现不同数据类型的add方法,就需要给每种类型都写一个重载方法,这显然不符合我们开发的需求.</p>
<p>&emsp;&emsp;如果我们在这里使用泛型的话,就不需要给每种数据类型都增加一个重载方法.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.doubleValue() + b.doubleValue() ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果我们在这里使用泛型的话,就不需要给每种数据类型都增加一个重载方法.</p>
<p>再看下面的情形</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/01.png" alt="step1"></p>
<p>&emsp;&emsp;在上面代码我们定义了一个List类型的集合,先向里面加入了两个String类型的值,然后又加入了一个Integer类型的值,这在Java编译期间是允许的,因为List默认的类型是Object.在后面的循环中,因为之前加入的数据类型不一样,很可能出现ClassCastException异常.</p>
<p> 从上我们可以大概总结到泛型有以下好处<br><font color=#ff0000>1,代码复用,增加代码拓展性</font><br><font color=#ff0000>2,消除强制类型转换,类型安全</font></p>
<h2 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h2><p>&emsp;&emsp;泛型可以用在类,接口,方法上,分别可以称为泛型类,泛型接口,泛型方法.</p>
<h4 id="泛型类-泛型接口"><a href="#泛型类-泛型接口" class="headerlink" title="泛型类/泛型接口"></a>泛型类/泛型接口</h4><p>&emsp;&emsp;泛型类和泛型接口的定义基本相同,就是引入一个类型变量T(其他大写字母也OK,一般约定俗成的有T,E,V,K,N等),并用&lt;&gt;括起来,放在类名/接口名的后面,泛型类和接口允许有多个类型变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型类(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">T</span>,<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> K result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>&emsp;&emsp;泛型方法,是在调用方法的时候指明泛型的具体类型,泛型方法可以在任意地方任意场景中使用,包括普通类和泛型类.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//泛型方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">V <span class="title">handleData</span><span class="params">(V data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<font color=#ff0000>一定要注意的是,并不是方法中参数或者返回值包含了泛型的就是泛型方法,只有在调用的时候需要指明泛型的才是泛型方法.</font></p>
<h2 id="限定类型变量"><a href="#限定类型变量" class="headerlink" title="限定类型变量"></a>限定类型变量</h2><p>&emsp;&emsp;有时候,我们需要对泛型的类型进行限定,比如说我们写一个泛型方法比较两个变量的大小,我们怎么确保传入的两个变量都一定有compareTo方法呢?这个时候我们就可以使用T extends Comparable对泛型的类型变量进行限制,<br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/02.png" alt="step2"></p>
<p>&emsp;&emsp;T表示应该绑定类型的子类型,Comparable表示绑定的类型,子类型和绑定类型可以试类,也可以是接口<br>&emsp;&emsp;这个时候如果我们试图传入一个没有实现接口Comparable的实例变量,将会发生变异错误<br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/3.png" alt="step3"></p>
<h2 id="泛型类的继承规则"><a href="#泛型类的继承规则" class="headerlink" title="泛型类的继承规则"></a>泛型类的继承规则</h2><p><font color=#0099FF>1,泛型参数是继承关系的,泛型类之间没有继承关系</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendPet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Pet&lt;Animal&gt; genericClass =<span class="keyword">new</span> Pet&lt;Cat&gt;(); <span class="comment">//错误</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=#0099FF>2,泛型类是可以继承其他泛型类的,比如List和ArrayList</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendPet</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Pet&lt;Animal&gt; genericClass =<span class="keyword">new</span> ExtendPet&lt;&gt;(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<h2 id="通配符使用"><a href="#通配符使用" class="headerlink" title="通配符使用"></a>通配符使用</h2><h3 id="数组的协变"><a href="#数组的协变" class="headerlink" title="数组的协变"></a>数组的协变</h3><p>&emsp;&emsp;在讲泛型通配符之前,我们先了解下数组,在Java中,数组是可以<font color=#0099FF>协变</font>的,什么是<font color=#0099FF>协变</font>,我们以下面的例子讲解下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingBa</span> <span class="keyword">extends</span> <span class="title">Dog</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Animal[] animals = <span class="keyword">new</span> Dog[<span class="number">5</span>];</span><br><span class="line">       animals[<span class="number">0</span>] = <span class="keyword">new</span> Dog();<span class="comment">//可以</span></span><br><span class="line">       animals[<span class="number">1</span>] = <span class="keyword">new</span> JingBa();<span class="comment">//可以</span></span><br><span class="line">       System.out.println(animals.getClass());</span><br><span class="line">       System.out.println(animals[<span class="number">0</span>].getClass());</span><br><span class="line">       System.out.println(animals[<span class="number">1</span>].getClass());</span><br><span class="line">       <span class="comment">//animals[2] = new Animal();//ArrayStoreException</span></span><br><span class="line">       <span class="comment">// animals[3] = new Cat();//ArrayStoreException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">----------------------------------------------------</span><br><span class="line">class [Lcom.company.genneric.Dog;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">company</span>.<span class="title">genneric</span>.<span class="title">Dog</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">com</span>.<span class="title">company</span>.<span class="title">genneric</span>.<span class="title">JingBa</span></span></span><br><span class="line"><span class="class">----------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,创建一个Dog数组并将他赋值给Animal数组的引用.像这种具有子父类关系的类,子类数组也是父类数组的情况就是<font color=#0099FF>数组协变</font><br>&emsp;&emsp;不过在使用<font color=#0099FF>数组协变</font>,也有些事情要注意,就是有些问题在运行的时候才能发现.还是看上面的代码.尽管Dog[]可以”向上转型”为Animal[],但是数组中实际的类型还是Dog对象,我们在上面放入Dog或者Dog的子类JingBa的对象时都是可以的,但是在放入Animal或者Cat对象的时候会在运行的时候报ArrayStoreException异常.<br>&emsp;&emsp;泛型设计的目的之一就是将一些运行时候的错误暴露在编译期间,我们下面使用Java提供的泛型容器List,看下会发生什么.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/07.png" alt="step7"><br>&emsp;&emsp;看到了,上面的代码根本无法编译,直接报错,当涉及到泛型的时候,尽管Dog是Animal的子类,ArrayList<Dog>却不是ArrayList<Animal>的子类,也就是说泛型不支持<font color=#0099FF>协变</font></p>
<h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><p>&emsp;&emsp;如果我们要实现类似上面数组的<font color=#0099FF>协变</font>怎么办呢,这时候我们就用到了通配符.Java中泛型通配符分为3种,我们依次来讲.</p>
<h4 id="上边界通配符"><a href="#上边界通配符" class="headerlink" title="上边界通配符"></a>上边界通配符</h4><p>&emsp;&emsp;使用<code>&lt;? extends Parent&gt;</code>的就是上边界通配符,他指定了泛型类型的上边界,类型参数都是Parent的子类,通过这种通配符可以实现泛型的”向上转型”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        list.add(new Dog());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new JingBa());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Cat()));//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object()));//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        Animal a = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,list的类型是List&lt;? extends Animal&gt;,可以把list看成是一个类型的List,这个类型是可以继承Animal的,但是需要注意的是,这并不是说这个List就可以持有Animal的任意类型.通配符代表的是某种特定的类型,但是上面的list没有指定实际的类型,它可以是Animal的任何子类型,Animal是它的上边界.</p>
<p>&emsp;&emsp;既然我们不知道这个list是什么类型,那我们如果安全的添加一个对象呢?在上面的例子中我们也看到了,无论是添加Dog,JingBa,Cat还是Object对象,编译器都会报错,唯一能通过编译的就是null.所以如果我们写了向上转型<code>&lt;? extends Parent&gt;</code>的泛型那么我们的List将失去添加任务对象的能力,及时Object对象也不行.</p>
<p>&emsp;&emsp;另外如果我们获取返回Animal的方法,这是可以的,因为在这个list中,不管它实际的类型到底是什么,肯定可以转型成Animal的,所有向上转型返回数据是允许的.</p>
<p><font color=#0099FF>总结:主要用于安全地访问数据，可以访问Parent及其子类型，并且不能写入非null的数据</font></p>
<h4 id="下边界通配符"><a href="#下边界通配符" class="headerlink" title="下边界通配符"></a>下边界通配符</h4><p>&emsp;&emsp;使用<code>&lt;? super Child&gt;</code>的就是下边界通配符,他指定了泛型类型的下边界,类型参数都是Child的基类,通过这种通配符可以实现泛型的”向下转型”.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;? <span class="keyword">super</span> Dog&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        list.add(<span class="keyword">new</span> JingBa());</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//        list.add(new Cat());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        Object object = list.get(<span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在上面的代码中,我们也不能确定list里的是什么类型,但是我们知道这个类型一定是Dog的基类(父类),因此我们向里面添加一个Dog对象或者Dog子类型的对象是安全的,这些对象都可以向上转型为Dog.我们在取出list里面的数据的时候,返回的一定是Dog的基类(父类),但到底是哪一个基类(父类)我们是不知道的,但在java中所有的类型都继承自Object,所有在list取出的数据,返回的一定是Object.</p>
<p><font color=#0099FF>总结:主要用于安全地写入数据，可以写入Child及其子类型</font></p>
<h4 id="无边界通配符"><a href="#无边界通配符" class="headerlink" title="无边界通配符"></a>无边界通配符</h4><p><code>&lt;?&gt;</code>无边界通配符,没有任何限定.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        List&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        list.add(new Animal());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Dog());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Cat());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line"><span class="comment">//        list.add(new Object());//编译错误,Compile Error:cant&#x27;t add any type of object</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        Object object = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<code>List&lt;?&gt;</code>表示持有某种特定类型的List,但是这种List并没有指定具体类型,这是不安全的,所以我们不能向里面添加除null以外的对象</p>
<h5 id="List-lt-gt-与List的区别"><a href="#List-lt-gt-与List的区别" class="headerlink" title="List&lt;?&gt;与List的区别?"></a><code>List&lt;?&gt;</code>与List的区别?</h5><p>&emsp;&emsp;List没有泛型参数,表明这个List持有元素的类型是Object,因此可以添加任何类型的对象,不过编译器会有警告信息.</p>
<h2 id="泛型中的约束和局限性"><a href="#泛型中的约束和局限性" class="headerlink" title="泛型中的约束和局限性"></a>泛型中的约束和局限性</h2><p> <font color=#ff0000>1,不能用基本数据类型实例化类型参数</font><br> <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/4.png" alt="step4"></p>
<p>  <font color=#ff0000>2,运行时类型查询只适用于原始类型</font><br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/5.png" alt="step5"></p>
<p>  <font color=#ff0000>3,泛型类的静态变量或者方法不能使用泛型类型</font><br>  注:静态方法本身就是泛型方法除外<br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/6.png" alt="step6"><br>   &emsp;&emsp;不能在静态方法和变量中引用泛型类型变量,因为泛型是在对象创建的时候才知道是什么类型,而对象创建代码的执行顺序是static,构造方法,所以在对象初始化之前static的部分已经执行了.</p>
<p>  <font color=#ff0000>4,不能创建泛型数组</font><br>  <img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/java/01/08.png" alt="step8"></p>
<h2 id="虚拟机中泛型的实现-类型擦除"><a href="#虚拟机中泛型的实现-类型擦除" class="headerlink" title="虚拟机中泛型的实现-类型擦除"></a>虚拟机中泛型的实现-类型擦除</h2><p>&emsp;&emsp;Java泛型是在Java1.5以后才出现的,在Java早期版本中并没有泛型概念,为了向下兼容,Java泛型只存在在编译期,在编译后,就会替换成原生类型,并在相应的地方插入强制转换类型的代码,因此对于运行期的Java语言来说,ArrayList<Int>和ArrayList<String>就是一个类,这种编译后去除类型信息的方式就叫做类型擦除.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">        Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1==c2);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;泛型参数会擦除到他的第一个边界,如果参数类型是单独的一个T,那么最终会擦除到Object,相当于所有使用T的地方都会被Object替换,对于虚拟机来说,最终保存的参数类型还是Object.之所以还可以取出来我们传入的参数类型,是因为编译器在编译生成字节码的过程中,插入了类型转换的代码.</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射</title>
    <url>/java/02_Java%E5%8F%8D%E5%B0%84.html</url>
    <content><![CDATA[<p>@<a href="Java%E5%8F%8D%E5%B0%84">TOC</a></p>
<h2 id="什么是java反射"><a href="#什么是java反射" class="headerlink" title="什么是java反射"></a>什么是java反射</h2><p>&emsp;&emsp;反射(Reflect)之中包含一个”反”字,所以要了解反射,我们先从”正”开始.<br>&emsp;&emsp;一般情况下,我们使用某个类的时候,必定知道它是什么类,是用来做什么的,包含了哪些属性和方法.于是我们直接对这个类进行实例化,之后使用这个类对象进行操作.<br>&emsp;&emsp;反射(Reflect)则是一种我们一开始不知道要初始化的类是什么,在程序运行的时候才知道类是什么.并借助Java中的API获取到类的内部信息,并可以直接操作属性和方法</p>
<h2 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h2><h3 id="三级目录"><a href="#三级目录" class="headerlink" title="三级目录"></a>三级目录</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm报错 Environment location directory is not empty解决</title>
    <url>/idea/error/pycharm/01_Environment-location-directory-is-not-empty%E9%94%99%E8%AF%AF.html</url>
    <content><![CDATA[<h1 id="出现情景"><a href="#出现情景" class="headerlink" title="出现情景"></a>出现情景</h1><p>&emsp;&emsp;重新安装PyCharm导入之前的项目,或者使用Pycharm创建新项目的时候可能会出现<br><font color=#0099FF>Environment location directory is not empty</font>提示.</p>
<h1 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h1><p>&emsp;&emsp;配置环境的目录不是空的</p>
<h1 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h1><p>&emsp;&emsp;将Project interpreter 的Location修改为空文件夹,建议放入一个统一的目录下,方便管理.<br><img src="https://blog-1300139959.cos.ap-shanghai.myqcloud.com/idea/pycharm/error/01/02.png" alt="修改Location"></p>
]]></content>
      <categories>
        <category>错误记录</category>
      </categories>
      <tags>
        <tag>Idea使用问题</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
</search>
